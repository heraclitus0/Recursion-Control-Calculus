# -*- coding: utf-8 -*-
"""Naive_Rcc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19yp146pEYtKG88SifXsHZqVaHfKOQA7z
"""

"""
Recursion Control Calculus vs Naïve Agent Comparative Simulation
===============================================================

This module simulates epistemic state evolution in a noisy volatile environment,
comparing:
- a Naïve agent (linear update rule)
- a Recursion Control Calculus (RCC) agent with rupture control and epistemic misalignment regulation.

Plots cumulative epistemic state evolution, misalignment growth, and rupture event logs.

Aligned Meta-Theorems:
- Meta-Theorem 1: Operator closure over ℝ
- Meta-Theorem 2: Guaranteed rupture termination
- Meta-Theorem 3: Bounded misalignment growth
- Meta-Theorem 4: Deterministic recursion/rupture alternation
"""

import numpy as np
import matplotlib.pyplot as plt

# Simulation Parameters

timesteps = 300               # Number of recursion cycles
V_0 = 0.5                     # Initial epistemic state (𝓥₀)
Θ_0 = 0.35                    # Initial rupture threshold (Θ₀)
Δt = 0.1                      # Time differential for divergence calculation
sigma = 0.05                  # Standard deviation for threshold noise

# State Initialization

V_calc = V_0                  # RCC agent epistemic state (𝓥)
V_naive = V_0                 # Naïve agent epistemic state
E_field = 0.0                 # RCC agent cumulative misalignment (𝓔)

# Logs for Simulation Tracking

V_calc_trace = []             # RCC agent epistemic state trace
V_naive_trace = []            # Naïve agent epistemic state trace
E_trace = []                  # Misalignment field trace (RCC agent)
rupture_log = []              # Rupture event log (1 if rupture, else 0)

# Function Definitions (Operators)

def distortion(R, V):
    """Compute epistemic distortion Δ = |R - 𝓥|."""
    return abs(R - V)

def threshold(E):
    """Compute dynamic rupture threshold Θ = Θ₀ + a×𝓔 + N(0,σ²)."""
    return Θ_0 + 0.05 * E + np.random.normal(0, sigma)

def monad(V_prev, delta, E):
    """Apply recursion realignment (Continuity Monad ⊙)."""
    k = np.random.uniform(0.3, 0.7)
    return V_prev + k * delta * (1 + E)

# Main Simulation Loop

for t in range(timesteps):
    R_t = np.random.normal(0.5, 0.3)   # Generate noisy reception signal

    # Naïve agent linear update
    delta_naive = abs(R_t - V_naive)
    V_naive += 0.2 * delta_naive

    # RCC agent recursion update
    delta_calc = distortion(R_t, V_calc)
    current_threshold = threshold(E_field)

    if delta_calc <= current_threshold:
        V_calc = monad(V_calc, delta_calc, E_field)
        E_field += 0.1 * delta_calc
        rupture = 0
    else:
        V_calc = V_0
        E_field = 0
        rupture = 1

    # Log states
    V_calc_trace.append(V_calc)
    V_naive_trace.append(V_naive)
    E_trace.append(E_field)
    rupture_log.append(rupture)

# Results Visualization

plt.figure(figsize=(16, 10))

# Epistemic state evolution
plt.subplot(3, 1, 1)
plt.plot(V_calc_trace, label=r'Calc Agent ($\mathcal{V}$)')
plt.plot(V_naive_trace, label='Naïve Agent')
plt.title(r'Epistemic State Evolution — RCC vs Naïve')
plt.legend()

# Cumulative epistemic misalignment
plt.subplot(3, 1, 2)
plt.plot(E_trace, label=r'Epistemic Misalignment ($\mathcal{E}$) — RCC Agent')
plt.title(r'Cumulative Misalignment ($\mathcal{E}(t)$) for RCC Agent')
plt.legend()

# Rupture event log
plt.subplot(3, 1, 3)
plt.plot(rupture_log, label=r'Rupture Events ($\Theta$)')
plt.title(r'Rupture Events Over Time — RCC Agent')
plt.ylim(-0.1, 1.1)
plt.legend()

plt.tight_layout()
plt.show()



#Noisy Sequential Classification with Concept Drift
import numpy as np
import matplotlib.pyplot as plt

# PARAMETERS AND CONSTANTS

timesteps = 500             # Number of recursion cycles
V_0 = 0.5                   # Initial epistemic memory projection state (𝓥₀)
Theta_0 = 0.35              # Initial volatility threshold (Θ₀)
sigma_reception = 0.3       # Std deviation of reception field noise (R)
sigma_threshold = 0.025     # Std deviation of dynamic threshold perturbation
c = 0.1                     # Cumulative misalignment scaling factor (𝓔 increment factor)
a = 0.05                    # Threshold scaling coefficient w.r.t. misalignment field
dt = 0.1                    # Time differential (for divergence calculation)

# STATE INITIALIZATION

V = V_0                     # Epistemic memory projection field
E_field = 0.0               # Cumulative epistemic misalignment field

# LOGS FOR SIMULATION TRACKING

V_trace = []                # Epistemic memory states log
R_trace = []                # Received signals log
Theta_trace = []            # Dynamic thresholds log
E_trace = []                # Misalignment values log
Delta_trace = []            # Distortion values log
Div_trace = []              # Projected divergence log
rupture_log = []            # Rupture events log (1 if rupture, else 0)

# FUNCTION DEFINITIONS

def generate_reception(V_t):
    """Generates epistemically perturbed reception signal R(t) with Gaussian noise."""
    return V_t + np.random.normal(0, sigma_reception)

def calc_distortion(R_t, V_t):
    """Computes absolute epistemic distortion Δ(t) = |R(t) − V(t)|."""
    return abs(R_t - V_t)

def calc_threshold(E_t):
    """Computes dynamic rupture threshold Θ(t)."""
    return Theta_0 + a * E_t + np.random.normal(0, sigma_threshold)

def continuity_monad(V_prev, delta, E_prev):
    """Applies recursion realignment operator (⊙) if recursion continues."""
    k = np.random.uniform(0.3, 0.7)
    return V_prev + k * delta * (1 + E_prev)

def calc_divergence(R_t, V_t):
    """Computes projected divergence = (R(t) − V(t)) / Δt."""
    return (R_t - V_t) / dt

# MAIN RECURSION SIMULATION LOOP

for t in range(timesteps):
    R_t = generate_reception(V)
    delta_t = calc_distortion(R_t, V)
    Theta_t = calc_threshold(E_field)
    divergence_t = calc_divergence(R_t, V)

    if delta_t <= Theta_t:
        V_new = continuity_monad(V, delta_t, E_field)
        E_new = E_field + c * delta_t
        rupture = 0
    else:
        V_new = V_0
        E_new = 0.0
        rupture = 1

    V_trace.append(V_new)
    R_trace.append(R_t)
    Theta_trace.append(Theta_t)
    E_trace.append(E_new)
    Delta_trace.append(delta_t)
    Div_trace.append(divergence_t)
    rupture_log.append(rupture)

    V = V_new
    E_field = E_new

# VISUALIZATION OF RESULTS

plt.figure(figsize=(18, 12))

plt.subplot(4, 1, 1)
plt.plot(V_trace, label='Memory Field V')
plt.plot(R_trace, label='Reception R', linestyle='dotted')
plt.title("Epistemic Memory Projection vs. Reception Field")
plt.legend()

plt.subplot(4, 1, 2)
plt.plot(Delta_trace, label='Distortion Δ(t)', color='orange')
plt.title("Epistemic Distortion Over Recursion Cycles")
plt.legend()

plt.subplot(4, 1, 3)
plt.plot(E_trace, label='Misalignment Field E(t)', color='green')
plt.title("Cumulative Epistemic Misalignment Growth")
plt.legend()

plt.subplot(4, 1, 4)
plt.plot(Div_trace, label='Projected Divergence', color='purple')
plt.scatter(range(timesteps), [0.7 if rupture_log[i] == 1 else np.nan for i in range(timesteps)],
            color='red', marker='x', label='Rupture Events')
plt.title("Projected Divergence and Rupture Occurrences")
plt.legend()

plt.tight_layout()
plt.show()