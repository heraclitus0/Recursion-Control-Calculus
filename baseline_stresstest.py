# -*- coding: utf-8 -*-
"""baseline_stresstest.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QBLvL90Kygt2fN25wxd5e3BeSCQ-asQ_
"""

#Baseline Recursion System Results
import numpy as np
import matplotlib.pyplot as plt

# PARAMETERS AND CONSTANTS

timesteps = 500                     # Number of recursion cycles
base_threshold = 0.35               # Initial rupture threshold
sigma_reception = 0.18              # Noise magnitude in reception field
sigma_threshold = 0.015             # Noise in threshold scaling
adjustment_scale = 0.55             # Adjustment factor multiplier
cumulative_scale = 0.075            # Misalignment growth scaling
threshold_scale_factor = 0.04       # Sensitivity of threshold to misalignment
dt = 0.1                            # Time differential for divergence

# STATE INITIALIZATION

V = [0.5]                           # Memory projection field values log
R = []                              # Reception field values log
E_field = [0.0]                     # Cumulative epistemic misalignment field values log
rupture_events = []                 # Rupture event log (1 if rupture, else 0)
projected_divergence = []           # Projected divergence values log
distortion_trace = []               # Distortion values log

# FUNCTION DEFINITIONS

def generate_reception(V_t):
    """Generates perturbed reception R(t)."""
    return V_t + np.random.normal(0, sigma_reception)

def calc_distortion(R_t, V_t):
    """Calculates distortion Δ(t) = |R(t) - V(t)|."""
    return abs(R_t - V_t)

def apply_monad(V_t, delta_t, E_t):
    """Applies Continuity Monad (recursion adjustment)."""
    return V_t + adjustment_scale * delta_t * (1 + E_t)

# MAIN SIMULATION LOOP

cumulative_misalignment = 0.0

for t in range(timesteps):
    R_t = generate_reception(V[-1])
    R.append(R_t)

    delta_t = calc_distortion(R_t, V[-1])
    distortion_trace.append(delta_t)

    cumulative_misalignment += delta_t * cumulative_scale
    E_field.append(cumulative_misalignment)

    dynamic_threshold = base_threshold + cumulative_misalignment * threshold_scale_factor + np.random.normal(0, sigma_threshold)
    divergence = (R_t - V[-1]) / (dt if t else 1)
    projected_divergence.append(divergence)

    if delta_t <= dynamic_threshold:
        V_new = apply_monad(V[-1], delta_t, cumulative_misalignment)
        rupture_events.append(0)
    else:
        V_new = 0.5
        cumulative_misalignment = 0
        rupture_events.append(1)

    V.append(V_new)

# VISUALIZATION OF RESULTS

plt.figure(figsize=(18, 12))

# Memory projection vs. reception
plt.subplot(4, 1, 1)
plt.plot(V, label='Memory Field V')
plt.plot(R, label='Reception R', linestyle='dotted')
plt.title("Memory Projection vs. Reception")
plt.legend()

# Distortion over time
plt.subplot(4, 1, 2)
plt.plot(distortion_trace, label='Distortion Δ(t)', color='orange')
plt.title("Distortion Over Time")
plt.legend()

# Cumulative misalignment growth
plt.subplot(4, 1, 3)
plt.plot(E_field, label='Epistemic Misalignment E(t)', color='green')
plt.title("Cumulative Epistemic Misalignment")
plt.legend()

# Projected divergence and rupture occurrences
plt.subplot(4, 1, 4)
plt.plot(projected_divergence, label='Projected Divergence', color='purple')
plt.scatter(range(timesteps), [0.7 if rupture_events[i] == 1 else np.nan for i in range(timesteps)],
            color='red', marker='x', label='Rupture Events')
plt.title("Projected Divergence and Rupture Events")
plt.legend()

plt.tight_layout()
plt.show()



#stress test
import numpy as np
import matplotlib.pyplot as plt

# PARAMETERS AND CONSTANTS

timesteps = 600                     # Number of recursion cycles
base_threshold = 0.35               # Initial rupture threshold
sigma_reception = 0.35              # Increased reception noise (extreme perturbation)
sigma_threshold = 0.025             # Noise in dynamic threshold
adjustment_min, adjustment_max = 0.3, 0.7  # Monad adjustment scaling range
cumulative_scale = 0.1              # Misalignment accumulation factor
threshold_scale_factor = 0.05       # Threshold sensitivity to misalignment
dt = 0.1                            # Time differential for divergence calculation

# STATE INITIALIZATION

V = [0.5]                           # Memory field log
R = []                              # Reception log
E_field = [0.0]                     # Cumulative misalignment log
rupture_events = []                 # Rupture event log
projected_divergence = []           # Divergence log
distortion_trace = []               # Distortion log

# FUNCTION DEFINITIONS

def generate_reception(V_t):
    """Generates reception R(t) with large Gaussian noise."""
    return V_t + np.random.normal(0, sigma_reception)

def calc_distortion(R_t, V_t):
    """Computes distortion as absolute difference."""
    return abs(R_t - V_t)

def apply_monad(V_t, delta_t, E_t):
    """Applies Continuity Monad adjustment."""
    adj_factor = np.random.uniform(adjustment_min, adjustment_max) * delta_t * (1 + E_t)
    return V_t + adj_factor

# MAIN SIMULATION LOOP


cumulative_misalignment = 0.0

for t in range(timesteps):
    R_t = generate_reception(V[-1])
    R.append(R_t)

    delta_t = calc_distortion(R_t, V[-1])
    distortion_trace.append(delta_t)

    cumulative_misalignment += delta_t * cumulative_scale
    E_field.append(cumulative_misalignment)

    dynamic_threshold = base_threshold + cumulative_misalignment * threshold_scale_factor + np.random.normal(0, sigma_threshold)
    divergence = (R_t - V[-1]) / (dt if t else 1)
    projected_divergence.append(divergence)

    if delta_t <= dynamic_threshold:
        V_new = apply_monad(V[-1], delta_t, cumulative_misalignment)
        rupture_events.append(0)
    else:
        V_new = 0.5
        cumulative_misalignment = 0.0
        rupture_events.append(1)

    V.append(V_new)

# ==========================
# VISUALIZATION OF RESULTS
# ==========================

plt.figure(figsize=(18, 12))

# Memory field vs. reception
plt.subplot(4, 1, 1)
plt.plot(V, label='Memory Field V')
plt.plot(R, label='Reception R', linestyle='dotted')
plt.title("Stress Test: Memory Projection vs. Reception (High Perturbation)")
plt.legend()

# Distortion over time
plt.subplot(4, 1, 2)
plt.plot(distortion_trace, label='Distortion Δ(t)', color='orange')
plt.title("Distortion Over Time (Stress Test)")
plt.legend()

# Cumulative epistemic misalignment
plt.subplot(4, 1, 3)
plt.plot(E_field, label='Misalignment E(t)', color='green')
plt.title("Cumulative Epistemic Misalignment (Stress Conditions)")
plt.legend()

# Projected divergence and rupture events
plt.subplot(4, 1, 4)
plt.plot(projected_divergence, label='Projected Divergence', color='purple')
plt.scatter(range(timesteps), [0.7 if rupture_events[i] == 1 else np.nan for i in range(timesteps)],
            color='red', marker='x', label='Rupture Events')
plt.title("Projected Divergence and Ruptures (Stress Test)")
plt.legend()

plt.tight_layout()
plt.show()