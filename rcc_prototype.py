# -*- coding: utf-8 -*-
"""Rcc_prototype.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HFJMDSFxDyjZNi7u_LJhLYdqq4ya0AMH
"""

#Prototype
import numpy as np
import matplotlib.pyplot as plt


# PARAMETERS AND GLOBAL CONFIGURATION


timesteps = 200                     # Total recursion cycles
V_0 = 0.5                           # Initial memory field value (baseline epistemic projection)
base_threshold = 0.35               # Initial rupture threshold
sigma_threshold = 0.025             # Standard deviation for threshold noise
sigma_reception = 0.3               # Reception noise perturbation
dt = 0.1                            # Time differential for divergence calculation
seed = 42                           # Random seed for reproducibility

np.random.seed(seed)


# STATE INITIALIZATION


V = V_0                             # Current memory projection field
E_field = 0.0                       # Cumulative epistemic misalignment field

# Tracking logs
V_trace = []                        # Memory projection history
E_trace = []                        # Misalignment field history
threshold_trace = []                # Dynamic threshold trace
distortion_trace = []               # Distortion (Δ) history
rupture_log = []                    # Rupture event log

# FUNCTION DEFINITIONS


def generate_reception(V_t):
    """Generates perturbed reception signal."""
    return V_t + np.random.normal(0, sigma_reception)

def calc_distortion(R_t, V_t):
    """Computes absolute distortion Δ(t)."""
    return abs(R_t - V_t)

def calc_threshold(E_t):
    """Computes dynamic rupture threshold Θ(t)."""
    return base_threshold + 0.05 * E_t + np.random.normal(0, sigma_threshold)

def update_misalignment(E_prev, delta_t):
    """Updates cumulative misalignment field."""
    return E_prev + 0.1 * delta_t

def apply_monad(V_prev, delta_t, E_prev):
    """Applies recursion realignment (Continuity Monad)."""
    k = np.random.uniform(0.3, 0.7)
    return V_prev + k * delta_t * (1 + E_prev)


# MAIN RECURSION SIMULATION LOOP


for t in range(timesteps):
    R_t = generate_reception(V)
    delta_t = calc_distortion(R_t, V)
    current_threshold = calc_threshold(E_field)

    if delta_t <= current_threshold:
        V_new = apply_monad(V, delta_t, E_field)
        E_new = update_misalignment(E_field, delta_t)
        rupture = 0
    else:
        V_new = V_0
        E_new = 0.0
        rupture = 1

    # Log current state
    V_trace.append(V_new)
    E_trace.append(E_new)
    threshold_trace.append(current_threshold)
    distortion_trace.append(delta_t)
    rupture_log.append(rupture)

    # Update for next timestep
    V = V_new
    E_field = E_new

# ====================================
# RESULTS VISUALIZATION
# ====================================

plt.figure(figsize=(16, 12))

# Memory Field Trajectory
plt.subplot(3, 1, 1)
plt.plot(V_trace, label='Memory Projection V(t)')
plt.title('Memory Projection Field Evolution Over Time')
plt.ylabel('Memory Projection V(t)')
plt.legend()
plt.grid(True)

# Cumulative Epistemic Misalignment
plt.subplot(3, 1, 2)
plt.plot(E_trace, label='Cumulative Misalignment E(t)', color='green')
plt.title('Cumulative Epistemic Misalignment Growth')
plt.ylabel('Misalignment E(t)')
plt.legend()
plt.grid(True)

# Distortion Field and Rupture Events
plt.subplot(3, 1, 3)
plt.plot(distortion_trace, label='Distortion Δ(t)', color='orange')
plt.scatter(range(timesteps),
            [0.7 if rupture_log[i] == 1 else np.nan for i in range(timesteps)],
            color='red', marker='x', label='Rupture Event')
plt.title('Distortion and Rupture Event Timeline')
plt.ylabel('Distortion Δ(t)')
plt.legend()
plt.grid(True)

plt.xlabel('Recursion Cycle')
plt.tight_layout()
plt.show()